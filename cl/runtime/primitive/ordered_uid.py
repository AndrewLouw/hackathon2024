# Copyright (C) 2023-present The Project Contributors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import binascii
import struct
import time
from bson import ObjectId
from bson.binary import UUID_SUBTYPE
from bson.binary import Binary
from typing import Union
from uuid import UUID

# TODO: Rename to TimeStamp, convert to factory method, use native GUID for storage


class OrderedUid:
    """
    A 16-byte unique identifier that consists of two Int64 elements:

    * First element representing creation time recorded as the number
      of ticks since the Unix epoch (1970).
    * Second element is randomized with the inclusion of machine-specific
      information to make the identifier unique in combination with the
      first element.

    OrderedUid has the same size as GUID and can be stored in a
    data type designed for GUID. Like GUID, it has extremely low collision
    probability, with added temporal ordering properties.

    OrderedUid has the following ordering guarantees:

    * When generated in the same process, OrderedUid will be sorted strictly
      according to the order they are generated, even if multiple identifiers
      are generated within the same system clock increment.
    * When generated by separate processes, OrderedUid will be sorted according
      to the order they are generated if they are generated more than one operating
      system clock increment apart, otherwise the sorting order is not defined.
      While the underlying tick data type has 100ns resolution, the operating
      system clock more typically has one increment per 10-20 ms.

    Because OrderedUid does not rely on a central server for generation,
    it can be used with distributed, web scale applications where getting
    a centrally incremented identifier would cause a performance hit.
    """

    __slots__ = ("__bytes",)

    __bytes: bytes
    """Bytes of length 16."""

    def __init__(self, value: Union[str, bytes] = None):
        """Create OrderedUid from hex string, bytes value or generate new."""

        # Generate bson ObjectId and get milliseconds timestamp
        if value is None:
            oid = ObjectId()
            time_now = time.time_ns() // 1000_000

            # Pack timestamp and concat with ObjectId bytes without timestamp
            ts_part = struct.pack(">q", time_now)
            self.__bytes = ts_part + oid.binary[4:]
        elif isinstance(value, str):
            if len(value) != 32:
                raise ValueError(
                    f"Cannot convert OrderedUid from string of length {len(value)}, "
                    f"expected 32-character hex string."
                )

            self.__bytes = bytes.fromhex(value)
        elif isinstance(value, bytes):
            if len(value) != 16:
                raise ValueError(
                    f"Can not convert OrderedUid from bytes of length {len(value)}, " f"expected 16-byte binary."
                )

            self.__bytes = value
        else:
            raise TypeError(
                f"Can not convert OrderedUid from value of type {type(value).__name__}, "
                f"expected 32-character hex string hex string or 16-byte binary."
            )

    @property
    def binary(self):
        """16-byte binary representation of this ObjectId."""
        return self.__bytes

    def to_bson(self) -> Binary:
        """Serialize OrderedUid to bson."""
        return Binary(self.__bytes, UUID_SUBTYPE)

    @classmethod
    def from_bson(cls, value: Union[Binary, UUID]) -> "OrderedUid":
        """Deserialize OrderedUid from bson."""

        if isinstance(value, Binary):
            if value.subtype != UUID_SUBTYPE:
                raise ValueError(f"Expected GUID Binary value, got {value.subtype}.")
            obj = cls(bytes(value))
        elif isinstance(value, UUID):
            obj = cls(value.bytes)
        else:
            raise TypeError(f"Expected Binary or UUID value type, got {type(value).__name__}")

        return obj

    def __str__(self):
        return binascii.hexlify(self.__bytes).decode()

    def __eq__(self, other):
        if not isinstance(other, OrderedUid):
            return False
        return self.binary == other.binary
